{"ts":1373144931945,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Phaser;\n(function (Phaser) {\n    (function (FX) {\n        /// <reference path=\"../../Phaser/Game.d.ts\" />\n        /// <reference path=\"../../Phaser/FXManager.d.ts\" />\n        /**\n        * Phaser - FX - Camera - Flash\n        *\n        * The camera is filled with the given color and returns to normal at the given duration.\n        */\n        (function (Camera) {\n            var Flash = (function () {\n                function Flash(game) {\n                    this._fxFlashComplete = null;\n                    this._fxFlashDuration = 0;\n                    this._fxFlashAlpha = 0;\n                    this._game = game;\n                }\n                Flash.prototype.start = /**\n                * The camera is filled with this color and returns to normal at the given duration.\n                *\n                * @param\tColor\t\tThe color you want to use in 0xRRGGBB format, i.e. 0xffffff for white.\n                * @param\tDuration\tHow long it takes for the flash to fade.\n                * @param\tOnComplete\tAn optional function you want to run when the flash finishes. Set to null for no callback.\n                * @param\tForce\t\tForce an already running flash effect to reset.\n                */\n                function (color, duration, onComplete, force) {\n                    if (typeof color === \"undefined\") { color = 0xffffff; }\n                    if (typeof duration === \"undefined\") { duration = 1; }\n                    if (typeof onComplete === \"undefined\") { onComplete = null; }\n                    if (typeof force === \"undefined\") { force = false; }\n                    if(force === false && this._fxFlashAlpha > 0) {\n                        //  You can't flash again unless you force it\n                        return;\n                    }\n                    if(duration <= 0) {\n                        duration = 1;\n                    }\n                    var red = color >> 16 & 0xFF;\n                    var green = color >> 8 & 0xFF;\n                    var blue = color & 0xFF;\n                    this._fxFlashColor = 'rgba(' + red + ',' + green + ',' + blue + ',';\n                    this._fxFlashDuration = duration;\n                    this._fxFlashAlpha = 1;\n                    this._fxFlashComplete = onComplete;\n                };\n                Flash.prototype.postUpdate = function () {\n                    //  Update the Flash effect\n                    if(this._fxFlashAlpha > 0) {\n                        this._fxFlashAlpha -= this._game.time.elapsed / this._fxFlashDuration;\n                        if(this._game.math.roundTo(this._fxFlashAlpha, -2) <= 0) {\n                            this._fxFlashAlpha = 0;\n                            if(this._fxFlashComplete !== null) {\n                                this._fxFlashComplete();\n                            }\n                        }\n                    }\n                };\n                Flash.prototype.postRender = function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                    if(this._fxFlashAlpha > 0) {\n                        this._game.stage.context.fillStyle = this._fxFlashColor + this._fxFlashAlpha + ')';\n                        this._game.stage.context.fillRect(cameraX, cameraY, cameraWidth, cameraHeight);\n                    }\n                };\n                return Flash;\n            })();\n            Camera.Flash = Flash;            \n        })(FX.Camera || (FX.Camera = {}));\n        var Camera = FX.Camera;\n    })(Phaser.FX || (Phaser.FX = {}));\n    var FX = Phaser.FX;\n})(Phaser || (Phaser = {}));\nvar Phaser;\n(function (Phaser) {\n    (function (FX) {\n        /// <reference path=\"../../Phaser/Game.d.ts\" />\n        /// <reference path=\"../../Phaser/system/Camera.d.ts\" />\n        /// <reference path=\"../../Phaser/FXManager.d.ts\" />\n        /**\n        * Phaser - FX - Camera - Template\n        *\n        * A Template FX file you can use to create your own Camera FX.\n        * If you don't use any of the methods below (i.e. preUpdate, render, etc) then DELETE THEM to avoid un-necessary calls by the FXManager.\n        */\n        (function (Camera) {\n            var Template = (function () {\n                function Template(game, parent) {\n                    this._game = game;\n                    this._parent = parent;\n                }\n                Template.prototype.start = /**\n                * You can name the function that starts the effect whatever you like, but we used 'start' in our effects.\n                */\n                function () {\n                };\n                Template.prototype.preUpdate = /**\n                * Pre-update is called at the start of the objects update cycle, before any other updates have taken place.\n                */\n                function () {\n                };\n                Template.prototype.postUpdate = /**\n                * Post-update is called at the end of the objects update cycle, after other update logic has taken place.\n                */\n                function () {\n                };\n                Template.prototype.preRender = /**\n                * Pre-render is called at the start of the object render cycle, before any transforms have taken place.\n                * It happens directly AFTER a canvas context.save has happened if added to a Camera.\n                */\n                function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                };\n                Template.prototype.render = /**\n                * render is called during the objects render cycle, right after all transforms have finished, but before any children/image data is rendered.\n                */\n                function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                };\n                Template.prototype.postRender = /**\n                * Post-render is called during the objects render cycle, after the children/image data has been rendered.\n                * It happens directly BEFORE a canvas context.restore has happened if added to a Camera.\n                */\n                function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                };\n                return Template;\n            })();\n            Camera.Template = Template;            \n        })(FX.Camera || (FX.Camera = {}));\n        var Camera = FX.Camera;\n    })(Phaser.FX || (Phaser.FX = {}));\n    var FX = Phaser.FX;\n})(Phaser || (Phaser = {}));\nvar Phaser;\n(function (Phaser) {\n    (function (FX) {\n        /// <reference path=\"../../Phaser/Game.d.ts\" />\n        /// <reference path=\"../../Phaser/system/Camera.d.ts\" />\n        /// <reference path=\"../../Phaser/FXManager.d.ts\" />\n        /**\n        * Phaser - FX - Camera - Mirror\n        *\n        * A Template FX file you can use to create your own Camera FX.\n        * If you don't use any of the methods below (i.e. preUpdate, render, etc) then DELETE THEM to avoid un-necessary calls by the FXManager.\n        */\n        (function (Camera) {\n            var Mirror = (function () {\n                function Mirror(game, parent) {\n                    this._mirrorColor = null;\n                    this.flipX = false;\n                    this.flipY = true;\n                    this.cls = false;\n                    this._game = game;\n                    this._parent = parent;\n                    this._canvas = document.createElement('canvas');\n                    this._canvas.width = parent.width;\n                    this._canvas.height = parent.height;\n                    this._context = this._canvas.getContext('2d');\n                }\n                Mirror.prototype.start = /**\n                * This is the rectangular region to grab from the Camera used in the Mirror effect\n                * It is rendered to the Stage at Mirror.x/y (note the use of Stage coordinates, not World coordinates)\n                */\n                function (x, y, region, fillColor) {\n                    if (typeof fillColor === \"undefined\") { fillColor = 'rgba(0,0,100,0.5)'; }\n                    this.x = x;\n                    this.y = y;\n                    this._mirrorX = region.x;\n                    this._mirrorY = region.y;\n                    this._mirrorWidth = region.width;\n                    this._mirrorHeight = region.height;\n                    if(fillColor) {\n                        this._mirrorColor = fillColor;\n                        this._context.fillStyle = this._mirrorColor;\n                    }\n                };\n                Mirror.prototype.postRender = /**\n                * Post-render is called during the objects render cycle, after the children/image data has been rendered.\n                * It happens directly BEFORE a canvas context.restore has happened if added to a Camera.\n                */\n                function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                    if(this.cls) {\n                        this._context.clearRect(0, 0, this._mirrorWidth, this._mirrorHeight);\n                    }\n                    this._sx = cameraX + this._mirrorX;\n                    this._sy = cameraY + this._mirrorY;\n                    if(this.flipX == true && this.flipY == false) {\n                        this._sx = 0;\n                    } else if(this.flipY == true && this.flipX == false) {\n                        this._sy = 0;\n                    }\n                    this._context.drawImage(this._game.stage.canvas, //\tSource Image\n                    this._sx, //\tSource X (location within the source image)\n                    this._sy, //\tSource Y\n                    this._mirrorWidth, //\tSource Width\n                    this._mirrorHeight, //\tSource Height\n                    0, //\tDestination X (where on the canvas it'll be drawn)\n                    0, //\tDestination Y\n                    this._mirrorWidth, //\tDestination Width (always same as Source Width unless scaled)\n                    this._mirrorHeight);\n                    //\tDestination Height (always same as Source Height unless scaled)\n                    if(this._mirrorColor) {\n                        this._context.fillRect(0, 0, this._mirrorWidth, this._mirrorHeight);\n                    }\n                    //this._game.stage.context.save();\n                    if(this.flipX && this.flipY) {\n                        this._game.stage.context.transform(-1, 0, 0, -1, this._mirrorWidth, this._mirrorHeight);\n                        this._game.stage.context.drawImage(this._canvas, -this.x, -this.y);\n                    } else if(this.flipX) {\n                        this._game.stage.context.transform(-1, 0, 0, 1, this._mirrorWidth, 0);\n                        this._game.stage.context.drawImage(this._canvas, -this.x, this.y);\n                    } else if(this.flipY) {\n                        this._game.stage.context.transform(1, 0, 0, -1, 0, this._mirrorHeight);\n                        this._game.stage.context.drawImage(this._canvas, this.x, -this.y);\n                    }\n                    //this._game.stage.context.restore();\n                                    };\n                return Mirror;\n            })();\n            Camera.Mirror = Mirror;            \n        })(FX.Camera || (FX.Camera = {}));\n        var Camera = FX.Camera;\n    })(Phaser.FX || (Phaser.FX = {}));\n    var FX = Phaser.FX;\n})(Phaser || (Phaser = {}));\nvar Phaser;\n(function (Phaser) {\n    (function (FX) {\n        /// <reference path=\"../../Phaser/Game.d.ts\" />\n        /// <reference path=\"../../Phaser/system/Camera.d.ts\" />\n        /// <reference path=\"../../Phaser/FXManager.d.ts\" />\n        /**\n        * Phaser - FX - Camera - Scanlines\n        *\n        * Give your game that classic retro feel!\n        */\n        (function (Camera) {\n            var Scanlines = (function () {\n                function Scanlines(game, parent) {\n                    this.spacing = 4;\n                    this.color = 'rgba(0, 0, 0, 0.3)';\n                    this._game = game;\n                    this._parent = parent;\n                }\n                Scanlines.prototype.postRender = function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                    this._game.stage.context.fillStyle = this.color;\n                    for(var y = cameraY; y < cameraHeight; y += this.spacing) {\n                        this._game.stage.context.fillRect(cameraX, y, cameraWidth, 1);\n                    }\n                };\n                return Scanlines;\n            })();\n            Camera.Scanlines = Scanlines;            \n        })(FX.Camera || (FX.Camera = {}));\n        var Camera = FX.Camera;\n    })(Phaser.FX || (Phaser.FX = {}));\n    var FX = Phaser.FX;\n})(Phaser || (Phaser = {}));\nvar Phaser;\n(function (Phaser) {\n    (function (FX) {\n        /// <reference path=\"../../Phaser/Game.d.ts\" />\n        /// <reference path=\"../../Phaser/FXManager.d.ts\" />\n        /**\n        * Phaser - FX - Camera - Shake\n        *\n        * A simple camera shake effect.\n        */\n        (function (Camera) {\n            var Shake = (function () {\n                function Shake(game, camera) {\n                    this._fxShakeIntensity = 0;\n                    this._fxShakeDuration = 0;\n                    this._fxShakeComplete = null;\n                    this._fxShakeOffset = new Phaser.MicroPoint(0, 0);\n                    this._fxShakeDirection = 0;\n                    this._fxShakePrevX = 0;\n                    this._fxShakePrevY = 0;\n                    this._game = game;\n                    this._parent = camera;\n                }\n                Shake.SHAKE_BOTH_AXES = 0;\n                Shake.SHAKE_HORIZONTAL_ONLY = 1;\n                Shake.SHAKE_VERTICAL_ONLY = 2;\n                Shake.prototype.start = /**\n                * A simple camera shake effect.\n                *\n                * @param\tIntensity\tPercentage of screen size representing the maximum distance that the screen can move while shaking.\n                * @param\tDuration\tThe length in seconds that the shaking effect should last.\n                * @param\tOnComplete\tA function you want to run when the shake effect finishes.\n                * @param\tForce\t\tForce the effect to reset (default = true, unlike flash() and fade()!).\n                * @param\tDirection\tWhether to shake on both axes, just up and down, or just side to side (use class constants SHAKE_BOTH_AXES, SHAKE_VERTICAL_ONLY, or SHAKE_HORIZONTAL_ONLY).\n                */\n                function (intensity, duration, onComplete, force, direction) {\n                    if (typeof intensity === \"undefined\") { intensity = 0.05; }\n                    if (typeof duration === \"undefined\") { duration = 0.5; }\n                    if (typeof onComplete === \"undefined\") { onComplete = null; }\n                    if (typeof force === \"undefined\") { force = true; }\n                    if (typeof direction === \"undefined\") { direction = Shake.SHAKE_BOTH_AXES; }\n                    if(!force && ((this._fxShakeOffset.x != 0) || (this._fxShakeOffset.y != 0))) {\n                        return;\n                    }\n                    //  If a shake is not already running we need to store the offsets here\n                    if(this._fxShakeOffset.x == 0 && this._fxShakeOffset.y == 0) {\n                        this._fxShakePrevX = this._parent.x;\n                        this._fxShakePrevY = this._parent.y;\n                    }\n                    this._fxShakeIntensity = intensity;\n                    this._fxShakeDuration = duration;\n                    this._fxShakeComplete = onComplete;\n                    this._fxShakeDirection = direction;\n                    this._fxShakeOffset.setTo(0, 0);\n                };\n                Shake.prototype.postUpdate = function () {\n                    //  Update the \"shake\" special effect\n                    if(this._fxShakeDuration > 0) {\n                        this._fxShakeDuration -= this._game.time.elapsed;\n                        if(this._game.math.roundTo(this._fxShakeDuration, -2) <= 0) {\n                            this._fxShakeDuration = 0;\n                            this._fxShakeOffset.setTo(0, 0);\n                            this._parent.x = this._fxShakePrevX;\n                            this._parent.y = this._fxShakePrevY;\n                            if(this._fxShakeComplete != null) {\n                                this._fxShakeComplete();\n                            }\n                        } else {\n                            if((this._fxShakeDirection == Shake.SHAKE_BOTH_AXES) || (this._fxShakeDirection == Shake.SHAKE_HORIZONTAL_ONLY)) {\n                                //this._fxShakeOffset.x = ((this._game.math.random() * this._fxShakeIntensity * this.worldView.width * 2 - this._fxShakeIntensity * this.worldView.width) * this._zoom;\n                                this._fxShakeOffset.x = (this._game.math.random() * this._fxShakeIntensity * this._parent.worldView.width * 2 - this._fxShakeIntensity * this._parent.worldView.width);\n                            }\n                            if((this._fxShakeDirection == Shake.SHAKE_BOTH_AXES) || (this._fxShakeDirection == Shake.SHAKE_VERTICAL_ONLY)) {\n                                //this._fxShakeOffset.y = (this._game.math.random() * this._fxShakeIntensity * this.worldView.height * 2 - this._fxShakeIntensity * this.worldView.height) * this._zoom;\n                                this._fxShakeOffset.y = (this._game.math.random() * this._fxShakeIntensity * this._parent.worldView.height * 2 - this._fxShakeIntensity * this._parent.worldView.height);\n                            }\n                        }\n                    }\n                };\n                Shake.prototype.preRender = function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                    if((this._fxShakeOffset.x != 0) || (this._fxShakeOffset.y != 0)) {\n                        this._parent.x = this._fxShakePrevX + this._fxShakeOffset.x;\n                        this._parent.y = this._fxShakePrevY + this._fxShakeOffset.y;\n                    }\n                };\n                return Shake;\n            })();\n            Camera.Shake = Shake;            \n        })(FX.Camera || (FX.Camera = {}));\n        var Camera = FX.Camera;\n    })(Phaser.FX || (Phaser.FX = {}));\n    var FX = Phaser.FX;\n})(Phaser || (Phaser = {}));\nvar Phaser;\n(function (Phaser) {\n    (function (FX) {\n        /// <reference path=\"../../Phaser/Game.d.ts\" />\n        /// <reference path=\"../../Phaser/FXManager.d.ts\" />\n        /**\n        * Phaser - FX - Camera - Fade\n        *\n        * The camera is filled with the given color and returns to normal at the given duration.\n        */\n        (function (Camera) {\n            var Fade = (function () {\n                function Fade(game) {\n                    this._fxFadeComplete = null;\n                    this._fxFadeDuration = 0;\n                    this._fxFadeAlpha = 0;\n                    this._game = game;\n                }\n                Fade.prototype.start = /**\n                * The camera is gradually filled with this color.\n                *\n                * @param\tColor\t\tThe color you want to use in 0xRRGGBB format, i.e. 0xffffff for white.\n                * @param\tDuration\tHow long it takes for the flash to fade.\n                * @param\tOnComplete\tAn optional function you want to run when the flash finishes. Set to null for no callback.\n                * @param\tForce\t\tForce an already running flash effect to reset.\n                */\n                function (color, duration, onComplete, force) {\n                    if (typeof color === \"undefined\") { color = 0x000000; }\n                    if (typeof duration === \"undefined\") { duration = 1; }\n                    if (typeof onComplete === \"undefined\") { onComplete = null; }\n                    if (typeof force === \"undefined\") { force = false; }\n                    if(force === false && this._fxFadeAlpha > 0) {\n                        //  You can't fade again unless you force it\n                        return;\n                    }\n                    if(duration <= 0) {\n                        duration = 1;\n                    }\n                    var red = color >> 16 & 0xFF;\n                    var green = color >> 8 & 0xFF;\n                    var blue = color & 0xFF;\n                    this._fxFadeColor = 'rgba(' + red + ',' + green + ',' + blue + ',';\n                    this._fxFadeDuration = duration;\n                    this._fxFadeAlpha = 0.01;\n                    this._fxFadeComplete = onComplete;\n                };\n                Fade.prototype.postUpdate = function () {\n                    //  Update the Fade effect\n                    if(this._fxFadeAlpha > 0) {\n                        this._fxFadeAlpha += this._game.time.elapsed / this._fxFadeDuration;\n                        if(this._game.math.roundTo(this._fxFadeAlpha, -2) >= 1) {\n                            this._fxFadeAlpha = 1;\n                            if(this._fxFadeComplete !== null) {\n                                this._fxFadeComplete();\n                            }\n                        }\n                    }\n                };\n                Fade.prototype.postRender = function (camera, cameraX, cameraY, cameraWidth, cameraHeight) {\n                    //  \"Fade\" FX\n                    if(this._fxFadeAlpha > 0) {\n                        this._game.stage.context.fillStyle = this._fxFadeColor + this._fxFadeAlpha + ')';\n                        this._game.stage.context.fillRect(cameraX, cameraY, cameraWidth, cameraHeight);\n                    }\n                };\n                return Fade;\n            })();\n            Camera.Fade = Fade;            \n        })(FX.Camera || (FX.Camera = {}));\n        var Camera = FX.Camera;\n    })(Phaser.FX || (Phaser.FX = {}));\n    var FX = Phaser.FX;\n})(Phaser || (Phaser = {}));\n"]],"start1":0,"start2":0,"length1":0,"length2":21828}]],"length":21828}
